enum BoatType {
  YACHT
  SAILBOAT
  MOTORBOAT
  CATAMARAN
  JETSKI
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  IN_PROGRESS
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  PARTIAL
}

enum UserRole {
  GUEST
  OWNER
  ADMIN
}

type Location @aws_api_key @aws_cognito_user_pools {
  marina: String!
  state: String!
  coordinates: Coordinates!
}

type Coordinates @aws_api_key @aws_cognito_user_pools {
  latitude: Float!
  longitude: Float!
}

type Specifications @aws_api_key @aws_cognito_user_pools {
  length: Float!
  engine: String!
  fuel: String!
  year: Int!
}

type Availability @aws_api_key @aws_cognito_user_pools {
  available: Boolean!
  blockedDates: [String!]!
}

type ContactInfo {
  name: String!
  email: String!
  phone: String!
}

type Quote {
  subtotal: Float!
  taxes: Float!
  serviceFee: Float!
  totalAmount: Float!
  currency: String!
}

type User {
  id: ID!
  email: String!
  name: String!
  phone: String
  role: UserRole!
  verified: Boolean!
  rating: Float
  profileImage: String
  dateOfBirth: AWSDate
  address: String
  emergencyContact: ContactInfo
  ownedBoats(filter: ModelBoatFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBoatConnection
  bookings(filter: ModelBookingFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBookingConnection
  reservations(filter: ModelReservationFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelReservationConnection
  reviews(filter: ModelReviewFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelReviewConnection
  payments(filter: ModelPaymentFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelPaymentConnection
  notifications(filter: ModelNotificationFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelNotificationConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Boat @aws_api_key @aws_cognito_user_pools {
  id: ID!
  name: String!
  type: BoatType!
  description: String!
  capacity: Int!
  pricePerHour: Float!
  pricePerDay: Float!
  rating: Float
  reviews: Int
  images: [String!]!
  location: Location!
  specifications: Specifications!
  amenities: [String!]!
  availability: Availability!
  featured: Boolean!
  ownerId: ID!
  owner: User
  bookings(filter: ModelBookingFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelBookingConnection
  reservations(filter: ModelReservationFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelReservationConnection
  boatReviews(filter: ModelReviewFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelReviewConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Booking {
  id: ID!
  userId: ID!
  boatId: ID!
  boatOwnerId: ID!
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  totalHours: Int!
  totalDays: Int!
  pricePerHour: Float!
  pricePerDay: Float!
  totalAmount: Float!
  status: BookingStatus!
  paymentStatus: PaymentStatus!
  guestCount: Int!
  specialRequests: String
  user: User
  boat: Boat
  payment: Payment
  review: Review
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  bookingPaymentId: ID
  bookingReviewId: ID
}

type Reservation {
  id: ID!
  userId: ID!
  boatId: ID!
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  totalHours: Int!
  totalDays: Int!
  guestCount: Int!
  specialRequests: String
  contactInfo: ContactInfo!
  quote: Quote!
  status: String!
  expiresAt: AWSDateTime!
  user: User
  boat: Boat
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Payment {
  id: ID!
  userId: ID!
  bookingId: ID!
  amount: Float!
  currency: String!
  paymentMethod: String!
  paymentProvider: String
  transactionId: String
  status: PaymentStatus!
  paidAt: AWSDateTime
  refundedAt: AWSDateTime
  user: User
  booking: Booking
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Review @aws_api_key @aws_cognito_user_pools {
  id: ID!
  userId: ID!
  boatId: ID!
  bookingId: ID!
  rating: Int!
  comment: String
  images: [String!]
  cleanlinessRating: Int
  communicationRating: Int
  accuracyRating: Int
  valueRating: Int
  approved: Boolean!
  user: User
  boat: Boat
  booking: Booking
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Notification {
  id: ID!
  userId: ID!
  title: String!
  message: String!
  type: String!
  read: Boolean!
  relatedId: String
  actionUrl: String
  user: User
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

input ContactInfoInput {
  name: String!
  email: String!
  phone: String!
}

type ModelUserConnection {
  items: [User]!
  nextToken: String
}

input ModelUserRoleInput {
  eq: UserRole
  ne: UserRole
}

input ModelUserFilterInput {
  id: ModelIDInput
  email: ModelStringInput
  name: ModelStringInput
  phone: ModelStringInput
  role: ModelUserRoleInput
  verified: ModelBooleanInput
  rating: ModelFloatInput
  profileImage: ModelStringInput
  dateOfBirth: ModelStringInput
  address: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

type Query {
  getUser(id: ID!): User
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
  getBooking(id: ID!): Booking
  listBookings(filter: ModelBookingFilterInput, limit: Int, nextToken: String): ModelBookingConnection
  getReservation(id: ID!): Reservation
  listReservations(filter: ModelReservationFilterInput, limit: Int, nextToken: String): ModelReservationConnection
  getPayment(id: ID!): Payment
  listPayments(filter: ModelPaymentFilterInput, limit: Int, nextToken: String): ModelPaymentConnection
  getNotification(id: ID!): Notification
  listNotifications(filter: ModelNotificationFilterInput, limit: Int, nextToken: String): ModelNotificationConnection
  usersByEmail(email: String!, sortDirection: ModelSortDirection, filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
  bookingsByUserId(userId: ID!, sortDirection: ModelSortDirection, filter: ModelBookingFilterInput, limit: Int, nextToken: String): ModelBookingConnection
  bookingsByBoatId(boatId: ID!, sortDirection: ModelSortDirection, filter: ModelBookingFilterInput, limit: Int, nextToken: String): ModelBookingConnection
  bookingsByStatus(status: BookingStatus!, sortDirection: ModelSortDirection, filter: ModelBookingFilterInput, limit: Int, nextToken: String): ModelBookingConnection
  reservationsByUserId(userId: ID!, sortDirection: ModelSortDirection, filter: ModelReservationFilterInput, limit: Int, nextToken: String): ModelReservationConnection
  reservationsByBoatId(boatId: ID!, sortDirection: ModelSortDirection, filter: ModelReservationFilterInput, limit: Int, nextToken: String): ModelReservationConnection
  paymentsByUserId(userId: ID!, sortDirection: ModelSortDirection, filter: ModelPaymentFilterInput, limit: Int, nextToken: String): ModelPaymentConnection
  paymentsByBookingId(bookingId: ID!, sortDirection: ModelSortDirection, filter: ModelPaymentFilterInput, limit: Int, nextToken: String): ModelPaymentConnection
  paymentsByStatus(status: PaymentStatus!, sortDirection: ModelSortDirection, filter: ModelPaymentFilterInput, limit: Int, nextToken: String): ModelPaymentConnection
  notificationsByUserId(userId: ID!, sortDirection: ModelSortDirection, filter: ModelNotificationFilterInput, limit: Int, nextToken: String): ModelNotificationConnection
  getBoat(id: ID!): Boat @aws_api_key @aws_cognito_user_pools
  listBoats(filter: ModelBoatFilterInput, limit: Int, nextToken: String): ModelBoatConnection @aws_api_key @aws_cognito_user_pools
  boatsByName(name: String!, sortDirection: ModelSortDirection, filter: ModelBoatFilterInput, limit: Int, nextToken: String): ModelBoatConnection @aws_api_key @aws_cognito_user_pools
  boatsByType(type: BoatType!, sortDirection: ModelSortDirection, filter: ModelBoatFilterInput, limit: Int, nextToken: String): ModelBoatConnection @aws_api_key @aws_cognito_user_pools
  boatsByOwnerId(ownerId: ID!, sortDirection: ModelSortDirection, filter: ModelBoatFilterInput, limit: Int, nextToken: String): ModelBoatConnection @aws_api_key @aws_cognito_user_pools
  getReview(id: ID!): Review @aws_api_key @aws_cognito_user_pools
  listReviews(filter: ModelReviewFilterInput, limit: Int, nextToken: String): ModelReviewConnection @aws_api_key @aws_cognito_user_pools
  reviewsByUserId(userId: ID!, sortDirection: ModelSortDirection, filter: ModelReviewFilterInput, limit: Int, nextToken: String): ModelReviewConnection @aws_api_key @aws_cognito_user_pools
  reviewsByBoatId(boatId: ID!, sortDirection: ModelSortDirection, filter: ModelReviewFilterInput, limit: Int, nextToken: String): ModelReviewConnection @aws_api_key @aws_cognito_user_pools
  reviewsByBookingId(bookingId: ID!, sortDirection: ModelSortDirection, filter: ModelReviewFilterInput, limit: Int, nextToken: String): ModelReviewConnection @aws_api_key @aws_cognito_user_pools
}

input ModelUserConditionInput {
  email: ModelStringInput
  name: ModelStringInput
  phone: ModelStringInput
  role: ModelUserRoleInput
  verified: ModelBooleanInput
  rating: ModelFloatInput
  profileImage: ModelStringInput
  dateOfBirth: ModelStringInput
  address: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
  id: ModelStringInput
}

input CreateUserInput {
  id: ID
  email: String!
  name: String!
  phone: String
  role: UserRole!
  verified: Boolean!
  rating: Float
  profileImage: String
  dateOfBirth: AWSDate
  address: String
  emergencyContact: ContactInfoInput
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdateUserInput {
  id: ID!
  email: String
  name: String
  phone: String
  role: UserRole
  verified: Boolean
  rating: Float
  profileImage: String
  dateOfBirth: AWSDate
  address: String
  emergencyContact: ContactInfoInput
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeleteUserInput {
  id: ID!
}

type Mutation {
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User
  createBoat(input: CreateBoatInput!, condition: ModelBoatConditionInput): Boat
  updateBoat(input: UpdateBoatInput!, condition: ModelBoatConditionInput): Boat
  deleteBoat(input: DeleteBoatInput!, condition: ModelBoatConditionInput): Boat
  createBooking(input: CreateBookingInput!, condition: ModelBookingConditionInput): Booking
  updateBooking(input: UpdateBookingInput!, condition: ModelBookingConditionInput): Booking
  deleteBooking(input: DeleteBookingInput!, condition: ModelBookingConditionInput): Booking
  createReservation(input: CreateReservationInput!, condition: ModelReservationConditionInput): Reservation
  updateReservation(input: UpdateReservationInput!, condition: ModelReservationConditionInput): Reservation
  deleteReservation(input: DeleteReservationInput!, condition: ModelReservationConditionInput): Reservation
  createPayment(input: CreatePaymentInput!, condition: ModelPaymentConditionInput): Payment
  updatePayment(input: UpdatePaymentInput!, condition: ModelPaymentConditionInput): Payment
  deletePayment(input: DeletePaymentInput!, condition: ModelPaymentConditionInput): Payment
  createReview(input: CreateReviewInput!, condition: ModelReviewConditionInput): Review
  updateReview(input: UpdateReviewInput!, condition: ModelReviewConditionInput): Review
  deleteReview(input: DeleteReviewInput!, condition: ModelReviewConditionInput): Review
  createNotification(input: CreateNotificationInput!, condition: ModelNotificationConditionInput): Notification
  updateNotification(input: UpdateNotificationInput!, condition: ModelNotificationConditionInput): Notification
  deleteNotification(input: DeleteNotificationInput!, condition: ModelNotificationConditionInput): Notification
}

input ModelSubscriptionUserFilterInput {
  email: ModelSubscriptionStringInput
  name: ModelSubscriptionStringInput
  phone: ModelSubscriptionStringInput
  role: ModelSubscriptionStringInput
  verified: ModelSubscriptionBooleanInput
  rating: ModelSubscriptionFloatInput
  profileImage: ModelSubscriptionStringInput
  dateOfBirth: ModelSubscriptionStringInput
  address: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionUserFilterInput]
  or: [ModelSubscriptionUserFilterInput]
  id: ModelStringInput
}

type Subscription {
  onCreateUser(filter: ModelSubscriptionUserFilterInput, id: String): User @aws_subscribe(mutations: ["createUser"])
  onUpdateUser(filter: ModelSubscriptionUserFilterInput, id: String): User @aws_subscribe(mutations: ["updateUser"])
  onDeleteUser(filter: ModelSubscriptionUserFilterInput, id: String): User @aws_subscribe(mutations: ["deleteUser"])
  onCreateBooking(filter: ModelSubscriptionBookingFilterInput, userId: String, boatOwnerId: String): Booking @aws_subscribe(mutations: ["createBooking"])
  onUpdateBooking(filter: ModelSubscriptionBookingFilterInput, userId: String, boatOwnerId: String): Booking @aws_subscribe(mutations: ["updateBooking"])
  onDeleteBooking(filter: ModelSubscriptionBookingFilterInput, userId: String, boatOwnerId: String): Booking @aws_subscribe(mutations: ["deleteBooking"])
  onCreateReservation(filter: ModelSubscriptionReservationFilterInput, userId: String): Reservation @aws_subscribe(mutations: ["createReservation"])
  onUpdateReservation(filter: ModelSubscriptionReservationFilterInput, userId: String): Reservation @aws_subscribe(mutations: ["updateReservation"])
  onDeleteReservation(filter: ModelSubscriptionReservationFilterInput, userId: String): Reservation @aws_subscribe(mutations: ["deleteReservation"])
  onCreatePayment(filter: ModelSubscriptionPaymentFilterInput, userId: String): Payment @aws_subscribe(mutations: ["createPayment"])
  onUpdatePayment(filter: ModelSubscriptionPaymentFilterInput, userId: String): Payment @aws_subscribe(mutations: ["updatePayment"])
  onDeletePayment(filter: ModelSubscriptionPaymentFilterInput, userId: String): Payment @aws_subscribe(mutations: ["deletePayment"])
  onCreateNotification(filter: ModelSubscriptionNotificationFilterInput, userId: String): Notification @aws_subscribe(mutations: ["createNotification"])
  onUpdateNotification(filter: ModelSubscriptionNotificationFilterInput, userId: String): Notification @aws_subscribe(mutations: ["updateNotification"])
  onDeleteNotification(filter: ModelSubscriptionNotificationFilterInput, userId: String): Notification @aws_subscribe(mutations: ["deleteNotification"])
  onCreateBoat(filter: ModelSubscriptionBoatFilterInput): Boat @aws_subscribe(mutations: ["createBoat"]) @aws_api_key @aws_cognito_user_pools
  onUpdateBoat(filter: ModelSubscriptionBoatFilterInput): Boat @aws_subscribe(mutations: ["updateBoat"]) @aws_api_key @aws_cognito_user_pools
  onDeleteBoat(filter: ModelSubscriptionBoatFilterInput): Boat @aws_subscribe(mutations: ["deleteBoat"]) @aws_api_key @aws_cognito_user_pools
  onCreateReview(filter: ModelSubscriptionReviewFilterInput, userId: String): Review @aws_subscribe(mutations: ["createReview"]) @aws_api_key @aws_cognito_user_pools
  onUpdateReview(filter: ModelSubscriptionReviewFilterInput, userId: String): Review @aws_subscribe(mutations: ["updateReview"]) @aws_api_key @aws_cognito_user_pools
  onDeleteReview(filter: ModelSubscriptionReviewFilterInput, userId: String): Review @aws_subscribe(mutations: ["deleteReview"]) @aws_api_key @aws_cognito_user_pools
}

input LocationInput {
  marina: String!
  state: String!
  coordinates: CoordinatesInput!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

input SpecificationsInput {
  length: Float!
  engine: String!
  fuel: String!
  year: Int!
}

input AvailabilityInput {
  available: Boolean!
  blockedDates: [String!]!
}

type ModelBoatConnection @aws_api_key @aws_cognito_user_pools {
  items: [Boat]!
  nextToken: String
}

input ModelBoatTypeInput {
  eq: BoatType
  ne: BoatType
}

input ModelBoatFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  type: ModelBoatTypeInput
  description: ModelStringInput
  capacity: ModelIntInput
  pricePerHour: ModelFloatInput
  pricePerDay: ModelFloatInput
  rating: ModelFloatInput
  reviews: ModelIntInput
  images: ModelStringInput
  amenities: ModelStringInput
  featured: ModelBooleanInput
  ownerId: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelBoatFilterInput]
  or: [ModelBoatFilterInput]
  not: ModelBoatFilterInput
}

input ModelBoatConditionInput {
  name: ModelStringInput
  type: ModelBoatTypeInput
  description: ModelStringInput
  capacity: ModelIntInput
  pricePerHour: ModelFloatInput
  pricePerDay: ModelFloatInput
  rating: ModelFloatInput
  reviews: ModelIntInput
  images: ModelStringInput
  amenities: ModelStringInput
  featured: ModelBooleanInput
  ownerId: ModelIDInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelBoatConditionInput]
  or: [ModelBoatConditionInput]
  not: ModelBoatConditionInput
}

input CreateBoatInput {
  id: ID
  name: String!
  type: BoatType!
  description: String!
  capacity: Int!
  pricePerHour: Float!
  pricePerDay: Float!
  rating: Float
  reviews: Int
  images: [String!]!
  location: LocationInput!
  specifications: SpecificationsInput!
  amenities: [String!]!
  availability: AvailabilityInput!
  featured: Boolean!
  ownerId: ID!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdateBoatInput {
  id: ID!
  name: String
  type: BoatType
  description: String
  capacity: Int
  pricePerHour: Float
  pricePerDay: Float
  rating: Float
  reviews: Int
  images: [String!]
  location: LocationInput
  specifications: SpecificationsInput
  amenities: [String!]
  availability: AvailabilityInput
  featured: Boolean
  ownerId: ID
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeleteBoatInput {
  id: ID!
}

input ModelSubscriptionBoatFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  type: ModelSubscriptionStringInput
  description: ModelSubscriptionStringInput
  capacity: ModelSubscriptionIntInput
  pricePerHour: ModelSubscriptionFloatInput
  pricePerDay: ModelSubscriptionFloatInput
  rating: ModelSubscriptionFloatInput
  reviews: ModelSubscriptionIntInput
  images: ModelSubscriptionStringInput
  amenities: ModelSubscriptionStringInput
  featured: ModelSubscriptionBooleanInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionBoatFilterInput]
  or: [ModelSubscriptionBoatFilterInput]
  ownerId: ModelStringInput
}

type ModelBookingConnection @aws_api_key @aws_cognito_user_pools {
  items: [Booking]!
  nextToken: String
}

input ModelBookingStatusInput {
  eq: BookingStatus
  ne: BookingStatus
}

input ModelPaymentStatusInput {
  eq: PaymentStatus
  ne: PaymentStatus
}

input ModelBookingFilterInput {
  id: ModelIDInput
  userId: ModelIDInput
  boatId: ModelIDInput
  boatOwnerId: ModelIDInput
  startDate: ModelStringInput
  endDate: ModelStringInput
  totalHours: ModelIntInput
  totalDays: ModelIntInput
  pricePerHour: ModelFloatInput
  pricePerDay: ModelFloatInput
  totalAmount: ModelFloatInput
  status: ModelBookingStatusInput
  paymentStatus: ModelPaymentStatusInput
  guestCount: ModelIntInput
  specialRequests: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelBookingFilterInput]
  or: [ModelBookingFilterInput]
  not: ModelBookingFilterInput
  bookingPaymentId: ModelIDInput
  bookingReviewId: ModelIDInput
}

input ModelBookingConditionInput {
  userId: ModelIDInput
  boatId: ModelIDInput
  boatOwnerId: ModelIDInput
  startDate: ModelStringInput
  endDate: ModelStringInput
  totalHours: ModelIntInput
  totalDays: ModelIntInput
  pricePerHour: ModelFloatInput
  pricePerDay: ModelFloatInput
  totalAmount: ModelFloatInput
  status: ModelBookingStatusInput
  paymentStatus: ModelPaymentStatusInput
  guestCount: ModelIntInput
  specialRequests: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelBookingConditionInput]
  or: [ModelBookingConditionInput]
  not: ModelBookingConditionInput
  bookingPaymentId: ModelIDInput
  bookingReviewId: ModelIDInput
}

input CreateBookingInput {
  id: ID
  userId: ID!
  boatId: ID!
  boatOwnerId: ID!
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  totalHours: Int!
  totalDays: Int!
  pricePerHour: Float!
  pricePerDay: Float!
  totalAmount: Float!
  status: BookingStatus!
  paymentStatus: PaymentStatus!
  guestCount: Int!
  specialRequests: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  bookingPaymentId: ID
  bookingReviewId: ID
}

input UpdateBookingInput {
  id: ID!
  userId: ID
  boatId: ID
  boatOwnerId: ID
  startDate: AWSDateTime
  endDate: AWSDateTime
  totalHours: Int
  totalDays: Int
  pricePerHour: Float
  pricePerDay: Float
  totalAmount: Float
  status: BookingStatus
  paymentStatus: PaymentStatus
  guestCount: Int
  specialRequests: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  bookingPaymentId: ID
  bookingReviewId: ID
}

input DeleteBookingInput {
  id: ID!
}

input ModelSubscriptionBookingFilterInput {
  id: ModelSubscriptionIDInput
  boatId: ModelSubscriptionIDInput
  startDate: ModelSubscriptionStringInput
  endDate: ModelSubscriptionStringInput
  totalHours: ModelSubscriptionIntInput
  totalDays: ModelSubscriptionIntInput
  pricePerHour: ModelSubscriptionFloatInput
  pricePerDay: ModelSubscriptionFloatInput
  totalAmount: ModelSubscriptionFloatInput
  status: ModelSubscriptionStringInput
  paymentStatus: ModelSubscriptionStringInput
  guestCount: ModelSubscriptionIntInput
  specialRequests: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionBookingFilterInput]
  or: [ModelSubscriptionBookingFilterInput]
  bookingPaymentId: ModelSubscriptionIDInput
  bookingReviewId: ModelSubscriptionIDInput
  userId: ModelStringInput
  boatOwnerId: ModelStringInput
}

input QuoteInput {
  subtotal: Float!
  taxes: Float!
  serviceFee: Float!
  totalAmount: Float!
  currency: String!
}

type ModelReservationConnection @aws_api_key @aws_cognito_user_pools {
  items: [Reservation]!
  nextToken: String
}

input ModelReservationFilterInput {
  id: ModelIDInput
  userId: ModelIDInput
  boatId: ModelIDInput
  startDate: ModelStringInput
  endDate: ModelStringInput
  totalHours: ModelIntInput
  totalDays: ModelIntInput
  guestCount: ModelIntInput
  specialRequests: ModelStringInput
  status: ModelStringInput
  expiresAt: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelReservationFilterInput]
  or: [ModelReservationFilterInput]
  not: ModelReservationFilterInput
}

input ModelReservationConditionInput {
  userId: ModelIDInput
  boatId: ModelIDInput
  startDate: ModelStringInput
  endDate: ModelStringInput
  totalHours: ModelIntInput
  totalDays: ModelIntInput
  guestCount: ModelIntInput
  specialRequests: ModelStringInput
  status: ModelStringInput
  expiresAt: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelReservationConditionInput]
  or: [ModelReservationConditionInput]
  not: ModelReservationConditionInput
}

input CreateReservationInput {
  id: ID
  userId: ID!
  boatId: ID!
  startDate: AWSDateTime!
  endDate: AWSDateTime!
  totalHours: Int!
  totalDays: Int!
  guestCount: Int!
  specialRequests: String
  contactInfo: ContactInfoInput!
  quote: QuoteInput!
  status: String!
  expiresAt: AWSDateTime!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdateReservationInput {
  id: ID!
  userId: ID
  boatId: ID
  startDate: AWSDateTime
  endDate: AWSDateTime
  totalHours: Int
  totalDays: Int
  guestCount: Int
  specialRequests: String
  contactInfo: ContactInfoInput
  quote: QuoteInput
  status: String
  expiresAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeleteReservationInput {
  id: ID!
}

input ModelSubscriptionReservationFilterInput {
  id: ModelSubscriptionIDInput
  boatId: ModelSubscriptionIDInput
  startDate: ModelSubscriptionStringInput
  endDate: ModelSubscriptionStringInput
  totalHours: ModelSubscriptionIntInput
  totalDays: ModelSubscriptionIntInput
  guestCount: ModelSubscriptionIntInput
  specialRequests: ModelSubscriptionStringInput
  status: ModelSubscriptionStringInput
  expiresAt: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionReservationFilterInput]
  or: [ModelSubscriptionReservationFilterInput]
  userId: ModelStringInput
}

type ModelPaymentConnection {
  items: [Payment]!
  nextToken: String
}

input ModelPaymentFilterInput {
  id: ModelIDInput
  userId: ModelIDInput
  bookingId: ModelIDInput
  amount: ModelFloatInput
  currency: ModelStringInput
  paymentMethod: ModelStringInput
  paymentProvider: ModelStringInput
  transactionId: ModelStringInput
  status: ModelPaymentStatusInput
  paidAt: ModelStringInput
  refundedAt: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPaymentFilterInput]
  or: [ModelPaymentFilterInput]
  not: ModelPaymentFilterInput
}

input ModelPaymentConditionInput {
  userId: ModelIDInput
  bookingId: ModelIDInput
  amount: ModelFloatInput
  currency: ModelStringInput
  paymentMethod: ModelStringInput
  paymentProvider: ModelStringInput
  transactionId: ModelStringInput
  status: ModelPaymentStatusInput
  paidAt: ModelStringInput
  refundedAt: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelPaymentConditionInput]
  or: [ModelPaymentConditionInput]
  not: ModelPaymentConditionInput
}

input CreatePaymentInput {
  id: ID
  userId: ID!
  bookingId: ID!
  amount: Float!
  currency: String!
  paymentMethod: String!
  paymentProvider: String
  transactionId: String
  status: PaymentStatus!
  paidAt: AWSDateTime
  refundedAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdatePaymentInput {
  id: ID!
  userId: ID
  bookingId: ID
  amount: Float
  currency: String
  paymentMethod: String
  paymentProvider: String
  transactionId: String
  status: PaymentStatus
  paidAt: AWSDateTime
  refundedAt: AWSDateTime
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeletePaymentInput {
  id: ID!
}

input ModelSubscriptionPaymentFilterInput {
  id: ModelSubscriptionIDInput
  bookingId: ModelSubscriptionIDInput
  amount: ModelSubscriptionFloatInput
  currency: ModelSubscriptionStringInput
  paymentMethod: ModelSubscriptionStringInput
  paymentProvider: ModelSubscriptionStringInput
  transactionId: ModelSubscriptionStringInput
  status: ModelSubscriptionStringInput
  paidAt: ModelSubscriptionStringInput
  refundedAt: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionPaymentFilterInput]
  or: [ModelSubscriptionPaymentFilterInput]
  userId: ModelStringInput
}

type ModelReviewConnection @aws_api_key @aws_cognito_user_pools {
  items: [Review]!
  nextToken: String
}

input ModelReviewFilterInput {
  id: ModelIDInput
  userId: ModelIDInput
  boatId: ModelIDInput
  bookingId: ModelIDInput
  rating: ModelIntInput
  comment: ModelStringInput
  images: ModelStringInput
  cleanlinessRating: ModelIntInput
  communicationRating: ModelIntInput
  accuracyRating: ModelIntInput
  valueRating: ModelIntInput
  approved: ModelBooleanInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelReviewFilterInput]
  or: [ModelReviewFilterInput]
  not: ModelReviewFilterInput
}

input ModelReviewConditionInput {
  userId: ModelIDInput
  boatId: ModelIDInput
  bookingId: ModelIDInput
  rating: ModelIntInput
  comment: ModelStringInput
  images: ModelStringInput
  cleanlinessRating: ModelIntInput
  communicationRating: ModelIntInput
  accuracyRating: ModelIntInput
  valueRating: ModelIntInput
  approved: ModelBooleanInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelReviewConditionInput]
  or: [ModelReviewConditionInput]
  not: ModelReviewConditionInput
}

input CreateReviewInput {
  id: ID
  userId: ID!
  boatId: ID!
  bookingId: ID!
  rating: Int!
  comment: String
  images: [String!]
  cleanlinessRating: Int
  communicationRating: Int
  accuracyRating: Int
  valueRating: Int
  approved: Boolean!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdateReviewInput {
  id: ID!
  userId: ID
  boatId: ID
  bookingId: ID
  rating: Int
  comment: String
  images: [String!]
  cleanlinessRating: Int
  communicationRating: Int
  accuracyRating: Int
  valueRating: Int
  approved: Boolean
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeleteReviewInput {
  id: ID!
}

input ModelSubscriptionReviewFilterInput {
  id: ModelSubscriptionIDInput
  boatId: ModelSubscriptionIDInput
  bookingId: ModelSubscriptionIDInput
  rating: ModelSubscriptionIntInput
  comment: ModelSubscriptionStringInput
  images: ModelSubscriptionStringInput
  cleanlinessRating: ModelSubscriptionIntInput
  communicationRating: ModelSubscriptionIntInput
  accuracyRating: ModelSubscriptionIntInput
  valueRating: ModelSubscriptionIntInput
  approved: ModelSubscriptionBooleanInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionReviewFilterInput]
  or: [ModelSubscriptionReviewFilterInput]
  userId: ModelStringInput
}

type ModelNotificationConnection {
  items: [Notification]!
  nextToken: String
}

input ModelNotificationFilterInput {
  id: ModelIDInput
  userId: ModelIDInput
  title: ModelStringInput
  message: ModelStringInput
  type: ModelStringInput
  read: ModelBooleanInput
  relatedId: ModelStringInput
  actionUrl: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelNotificationFilterInput]
  or: [ModelNotificationFilterInput]
  not: ModelNotificationFilterInput
}

input ModelNotificationConditionInput {
  userId: ModelIDInput
  title: ModelStringInput
  message: ModelStringInput
  type: ModelStringInput
  read: ModelBooleanInput
  relatedId: ModelStringInput
  actionUrl: ModelStringInput
  createdAt: ModelStringInput
  updatedAt: ModelStringInput
  and: [ModelNotificationConditionInput]
  or: [ModelNotificationConditionInput]
  not: ModelNotificationConditionInput
}

input CreateNotificationInput {
  id: ID
  userId: ID!
  title: String!
  message: String!
  type: String!
  read: Boolean!
  relatedId: String
  actionUrl: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input UpdateNotificationInput {
  id: ID!
  userId: ID
  title: String
  message: String
  type: String
  read: Boolean
  relatedId: String
  actionUrl: String
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
}

input DeleteNotificationInput {
  id: ID!
}

input ModelSubscriptionNotificationFilterInput {
  id: ModelSubscriptionIDInput
  title: ModelSubscriptionStringInput
  message: ModelSubscriptionStringInput
  type: ModelSubscriptionStringInput
  read: ModelSubscriptionBooleanInput
  relatedId: ModelSubscriptionStringInput
  actionUrl: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  updatedAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionNotificationFilterInput]
  or: [ModelSubscriptionNotificationFilterInput]
  userId: ModelStringInput
}
